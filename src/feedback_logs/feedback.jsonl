{"id": "49b24bd9-b7a1-402d-ab27-35e5143b7938", "ts": "2025-11-06T16:36:16Z", "page": "rag", "choice_label": "Hétérogène", "choice_key": "hetero", "comment": "good", "code_before": "def f(n):\r\n    if n==1 or n==0:\r\n        return 1\r\n    a,b=1,1\r\n    for i in range(n):\r\n        a,b = b,a+b\r\n    return a", "code_after_hetero": "def f(n):\n    if n == 0 or n == 1:\n        return n\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return b", "code_after_simple": "def f(n):\n    if n == 0 or n == 1:\n        return 1\n    a, b = 1, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b", "code_after_ast": "def f(n):\n    if n == 1 or n == 0:\n        return 1\n    a, b = 1, 1\n    for _ in range(n - 1):\n        a, b = b, a + b\n    return a", "code_after_selected": "def f(n):\n    if n == 0 or n == 1:\n        return n\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return b"}
{"id": "186521ff-9a14-455a-848d-115688cd9cd0", "ts": "2025-11-07T14:31:53Z", "page": "rag", "choice_label": "Hétérogène", "choice_key": "hetero", "comment": "good", "code_before": "from multiprocessing import Process\r\n\r\ndef split_list(alist, wanted_parts=1):\r\n    length = len(alist)\r\n    return [alist[i * length // wanted_parts: (i + 1) * length // wanted_parts] for i in range(wanted_parts)]\r\n\r\ndef check_ip(iplist, masklist):\r\n    threads = 16\r\n    workList = {}\r\n\r\n    workList[0], workList[1], workList[2], workList[3], \\\r\n    workList[4], workList[5], workList[6], workList[7], \\\r\n    workList[8], workList[9], workList[10], workList[11], \\\r\n    workList[12], workList[13], workList[14], \\\r\n    workList[15] = split_list(iplist, 16)\r\n\r\n    processes = [\r\n        Process(target=include_worker, args=(workList[i], masklist)) for i\r\n        in range(0, threads)]\r\n\r\n    for p in processes:\r\n        p.start()\r\n\r\n    for p in processes:\r\n        p.join()", "code_after_hetero": "from multiprocessing import Process\n\ndef split_list(alist, wanted_parts=1):\n    length = len(alist)\n    return [alist[i * length // wanted_parts: (i + 1) * length // wanted_parts] for i in range(wanted_parts)]\n\ndef check_ip(iplist, masklist):\n    threads = 16\n    workList = {}\n\n    workList.update({i: split_list(iplist, 16)[i] for i in range(threads)})\n\n    processes = [\n        Process(target=include_worker, args=(workList[i], masklist)) for i in range(threads)\n    ]\n\n    for p in processes:\n        p.start()\n\n    for p in processes:\n        p.join()", "code_after_simple": "from multiprocessing import Pool\n\ndef split_list(alist, wanted_parts=1):\n    length = len(alist)\n    return [alist[i * length // wanted_parts: (i + 1) * length // wanted_parts] for i in range(wanted_parts)]\n\ndef check_ip(iplist, masklist):\n    threads = 16\n    workList = split_list(iplist, 16)\n\n    with Pool(threads) as pool:\n        pool.map(include_worker, [(workList[i], masklist) for i in range(threads)])", "code_after_ast": "from concurrent.futures import ThreadPoolExecutor\nfrom multiprocessing import Process\n\ndef split_list(alist, wanted_parts=1):\n    length = len(alist)\n    return [alist[i * length // wanted_parts: (i + 1) * length // wanted_parts] for i in range(wanted_parts)]\n\ndef check_ip(iplist, masklist):\n    threads = 16\n    workList = {}\n\n    workList[0], workList[1], workList[2], workList[3],\n    workList[4], workList[5], workList[6], workList[7],\n    workList[8], workList[9], workList[10], workList[11],\n    workList[12], workList[13], workList[14],\n    workList[15] = split_list(iplist, 16)\n\n    with ThreadPoolExecutor(max_workers=threads) as executor:\n        executor.map(include_worker, [workList[i] for i in range(threads)], [masklist]*threads)", "code_after_selected": "from multiprocessing import Process\n\ndef split_list(alist, wanted_parts=1):\n    length = len(alist)\n    return [alist[i * length // wanted_parts: (i + 1) * length // wanted_parts] for i in range(wanted_parts)]\n\ndef check_ip(iplist, masklist):\n    threads = 16\n    workList = {}\n\n    workList.update({i: split_list(iplist, 16)[i] for i in range(threads)})\n\n    processes = [\n        Process(target=include_worker, args=(workList[i], masklist)) for i in range(threads)\n    ]\n\n    for p in processes:\n        p.start()\n\n    for p in processes:\n        p.join()"}
{"id": "3e6f19b6-21ca-4b4a-8ca4-5f2a4dab3d9c", "ts": "2025-11-07T17:20:51Z", "page": "rag", "choice_label": "AST", "choice_key": "ast", "comment": "i", "code_before": "import pandas as pd\nimport numpy as np\n\ndef process_data(df):\n    result = []\n    for i in range(len(df)):\n        row = df.iloc[i]\n        row_sum = 0\n        for col in df.columns:\n            if row[col] is not None:\n                row_sum += row[col] * 2\n        for j in range(10):\n            row_sum += j\n        if row_sum > 100:\n            result.append(row_sum)\n        else:\n            result.append(row_sum * 0.5)\n    unique_vals = []\n    for val in result:\n        if val not in unique_vals:\n            unique_vals.append(val)\n    final_result = []\n    for val in unique_vals:\n        final_result.append(val ** 2)\n    array = np.zeros(len(final_result))\n    for k in range(len(final_result)):\n        array[k] = final_result[k]\n    total = 0\n    for val in array:\n        total += val\n    return total, final_result, array", "code_after_hetero": "", "code_after_simple": "import pandas as pd\nimport numpy as np\n\ndef process_data(df):\n    result = []\n    for i in range(len(df)):\n        row = df.iloc[i]\n        row_sum = 0\n        for col in df.columns:\n            if row[col] is not None:\n                row_sum += row[col] * 2\n        for j in range(10):\n            row_sum += j\n        if row_sum > 100:\n            result.append(row_sum)\n        else:\n            result.append(row_sum * 0.5)\n    unique_vals = []\n    for val in result:\n        if val not in unique_vals:\n            unique_vals.append(val)\n    final_result = []\n    for val in unique_vals:\n        final_result.append(val ** 2)\n    array = np.zeros(len(final_result))\n    for k in range(len(final_result)):\n        array[k] = final_result[k]\n    total = np.sum(array)\n    return total, final_result, array", "code_after_ast": "import pandas as pd\nimport numpy as np\n\ndef process_data(df):\n    row_sums = df.sum(axis=1) * 2 + np.arange(10).sum()\n    result = np.where(row_sums > 100, row_sums, row_sums * 0.5)\n    unique_vals = np.unique(result)\n    final_result = unique_vals ** 2\n    array = final_result\n    total = array.sum()\n    return total, final_result, array", "code_after_llm": "import pandas as pd\nimport numpy as np\n\ndef process_data(df):\n    result = []\n    for i in range(len(df)):\n        row = df.iloc[i]\n        row_sum = sum(row[col] * 2 for col in df.columns if row[col] is not None)\n        row_sum += sum(range(10))\n        result.append(row_sum * 0.5 if row_sum <= 100 else row_sum)\n    unique_vals = list(set(result))\n    final_result = [val ** 2 for val in unique_vals]\n    array = np.array(final_result)\n    total = np.sum(array)\n    return total, final_result, array", "code_after_selected": "import pandas as pd\nimport numpy as np\n\ndef process_data(df):\n    row_sums = df.sum(axis=1) * 2 + np.arange(10).sum()\n    result = np.where(row_sums > 100, row_sums, row_sums * 0.5)\n    unique_vals = np.unique(result)\n    final_result = unique_vals ** 2\n    array = final_result\n    total = array.sum()\n    return total, final_result, array"}
{"id": "87c7889d-8f4f-4e2d-9466-e85d24f33367", "ts": "2025-11-07T20:59:20Z", "page": "rag", "choice_label": "Simple (KB)", "choice_key": "simple", "comment": "Tres bonne optimisation", "code_before": "import time\r\nimport random\r\nimport numpy as np\r\nimport pandas as pd\r\n\r\n# Récursion coûteuse (sans cache)\r\ndef fib(n):\r\n    if n <= 1:\r\n        return n\r\n    return fib(n - 1) + fib(n - 2)\r\n\r\n# Fonction lente appelée par pandas.apply\r\ndef slow_row_apply(row):\r\n    x, y = row[\"a\"], row[\"b\"]\r\n\r\n    # Concaténation de chaînes dans une boucle (inefficace)\r\n    s = \"\"\r\n    for _ in range(50):\r\n        s += str(int((x * y) * 1000) % 7)\r\n\r\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\r\n    arr = []\r\n    for i in range(200):\r\n        arr = arr + [i % 5]\r\n\r\n    z = sum(arr)\r\n\r\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\r\n    if random.random() < 0.001:\r\n        time.sleep(0.01)\r\n\r\n    # Appel récursif coûteux par ligne\r\n    return fib(22) + z + len(s)\r\n\r\ndef main():\r\n    # Petit dataset pour rester raisonnable en temps d'exécution\r\n    df = pd.DataFrame({\r\n        \"a\": np.random.rand(50),\r\n        \"b\": np.random.rand(50),\r\n    })\r\n\r\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\r\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\r\n\r\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\r\n    out = pd.DataFrame()\r\n    for _, r in df.iterrows():\r\n        tmp = pd.DataFrame({\"v\": [r[\"z\"]]})\r\n        out = pd.concat([out, tmp])  # anti-pattern\r\n\r\n    # Somme non vectorisée\r\n    total = 0\r\n    for v in out[\"v\"]:\r\n        total = total + v\r\n\r\n    print(\"total:\", total)\r\n\r\nif __name__ == \"__main__\":\r\n    main()", "code_after_hetero": "import time\nimport random\nimport numpy as np\nimport pandas as pd\n\n# Récursion coûteuse (sans cache)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.iterrows():\n        tmp = pd.DataFrame({\"v\": [r[\"z\"]]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = 0\n    for v in out[\"v\"]:\n        total = total + v\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_simple": "import time\nimport random\nimport numpy as np\nimport pandas as pd\nfrom functools import lru_cache\n\n# Récursion coûteuse (avec cache)\n@lru_cache(None)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.itertuples():\n        tmp = pd.DataFrame({\"v\": [r.z]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = out[\"v\"].sum()\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_ast": "import time\nimport random\nimport numpy as np\nimport pandas as pd\nfrom functools import lru_cache\n\n# Récursion coûteuse (avec cache)\n@lru_cache(None)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.iterrows():\n        tmp = pd.DataFrame({\"v\": [r[\"z\"]]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = out[\"v\"].sum()\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_llm": "import time\nimport random\nimport numpy as np\nimport pandas as pd\n\n# Récursion coûteuse (sans cache)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = ''.join(str(int((x * y) * 1000) % 7) for _ in range(50))\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = [i % 5 for i in range(200)]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame({\"v\": df[\"z\"]})\n\n    # Somme non vectorisée\n    total = out[\"v\"].sum()\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_selected": "import time\nimport random\nimport numpy as np\nimport pandas as pd\nfrom functools import lru_cache\n\n# Récursion coûteuse (avec cache)\n@lru_cache(None)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.itertuples():\n        tmp = pd.DataFrame({\"v\": [r.z]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = out[\"v\"].sum()\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()"}
{"id": "6df13629-4132-4078-aaa8-6938111e815f", "ts": "2025-11-12T10:58:29Z", "page": "rag", "choice_label": "LLM seul", "choice_key": "llm", "comment": "good optimisation", "code_before": "import time\nimport random\nimport numpy as np\nimport pandas as pd\nfrom functools import lru_cache\n\n# Récursion coûteuse (avec cache)\n@lru_cache(None)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.iterrows():\n        tmp = pd.DataFrame({\"v\": [r[\"z\"]]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = out[\"v\"].sum()\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_hetero": "import time\nimport random\nimport numpy as np\nimport pandas as pd\n\n# Récursion coûteuse (sans cache)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.iterrows():\n        tmp = pd.DataFrame({\"v\": [r[\"z\"]]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = 0\n    for v in out[\"v\"]:\n        total = total + v\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_simple": "import time\nimport random\nimport numpy as np\nimport pandas as pd\nfrom functools import lru_cache\n\n# Récursion coûteuse (avec cache)\n@lru_cache(None)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.itertuples():\n        tmp = pd.DataFrame({\"v\": [r.z]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = out[\"v\"].sum()\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_ast": "import time\nimport random\nimport numpy as np\nimport pandas as pd\nfrom functools import lru_cache\n\n# Récursion coûteuse (avec cache)\n@lru_cache(None)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.iterrows():\n        tmp = pd.DataFrame({\"v\": [r[\"z\"]]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = out[\"v\"].sum()\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_llm": "import time\nimport random\nimport numpy as np\nimport pandas as pd\n\n# Récursion coûteuse (sans cache)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = ''.join(str(int((x * y) * 1000) % 7) for _ in range(50))\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = [i % 5 for i in range(200)]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame({\"v\": df[\"z\"]})\n\n    # Somme non vectorisée\n    total = out[\"v\"].sum()\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_selected": "import time\nimport random\nimport numpy as np\nimport pandas as pd\n\n# Récursion coûteuse (sans cache)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = ''.join(str(int((x * y) * 1000) % 7) for _ in range(50))\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = [i % 5 for i in range(200)]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame({\"v\": df[\"z\"]})\n\n    # Somme non vectorisée\n    total = out[\"v\"].sum()\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()"}
{"id": "2540bcf5-e352-4222-88cc-e35ebe0a1d54", "ts": "2025-11-12T13:33:19Z", "page": "rag", "choice_label": "AST", "choice_key": "ast", "comment": "good", "code_before": "import time\nimport random\nimport numpy as np\nimport pandas as pd\n\n# Récursion coûteuse (sans cache)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.iterrows():\n        tmp = pd.DataFrame({\"v\": [r[\"z\"]]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = 0\n    for v in out[\"v\"]:\n        total = total + v\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_hetero": "import time\nimport random\nimport numpy as np\nimport pandas as pd\n\n# Récursion coûteuse (sans cache)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.iterrows():\n        tmp = pd.DataFrame({\"v\": [r[\"z\"]]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = 0\n    for v in out[\"v\"]:\n        total = total + v\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_simple": "import time\nimport random\nimport numpy as np\nimport pandas as pd\nfrom functools import lru_cache\n\n# Récursion coûteuse (avec cache)\n@lru_cache(None)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.itertuples():\n        tmp = pd.DataFrame({\"v\": [r.z]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = out[\"v\"].sum()\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_ast": "import time\nimport random\nimport numpy as np\nimport pandas as pd\nfrom functools import lru_cache\n\n# Récursion coûteuse (avec cache)\n@lru_cache(None)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.iterrows():\n        tmp = pd.DataFrame({\"v\": [r[\"z\"]]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = out[\"v\"].sum()\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_llm": "import time\nimport random\nimport numpy as np\nimport pandas as pd\n\n# Récursion coûteuse (sans cache)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = ''.join(str(int((x * y) * 1000) % 7) for _ in range(50))\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = [i % 5 for i in range(200)]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame({\"v\": df[\"z\"]})\n\n    # Somme non vectorisée\n    total = out[\"v\"].sum()\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_selected": "import time\nimport random\nimport numpy as np\nimport pandas as pd\nfrom functools import lru_cache\n\n# Récursion coûteuse (avec cache)\n@lru_cache(None)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.iterrows():\n        tmp = pd.DataFrame({\"v\": [r[\"z\"]]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = out[\"v\"].sum()\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()"}
{"id": "31269d2f-d4b2-4530-b3ed-5efab57cdf13", "ts": "2025-11-12T14:21:39Z", "page": "rag", "choice_label": "Hétérogène", "choice_key": "hetero", "comment": "bonne optimisation", "code_before": "import time\nimport random\nimport numpy as np\nimport pandas as pd\n\n# Récursion coûteuse (sans cache)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.iterrows():\n        tmp = pd.DataFrame({\"v\": [r[\"z\"]]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = 0\n    for v in out[\"v\"]:\n        total = total + v\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_hetero": "import time\nimport random\nimport numpy as np\nimport pandas as pd\n\n# Récursion coûteuse (sans cache)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.iterrows():\n        tmp = pd.DataFrame({\"v\": [r[\"z\"]]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = 0\n    for v in out[\"v\"]:\n        total = total + v\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_simple": "import time\nimport random\nimport numpy as np\nimport pandas as pd\nfrom functools import lru_cache\n\n# Récursion coûteuse (avec cache)\n@lru_cache(None)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.itertuples():\n        tmp = pd.DataFrame({\"v\": [r.z]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = out[\"v\"].sum()\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_ast": "import time\nimport random\nimport numpy as np\nimport pandas as pd\nfrom functools import lru_cache\n\n# Récursion coûteuse (avec cache)\n@lru_cache(None)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.iterrows():\n        tmp = pd.DataFrame({\"v\": [r[\"z\"]]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = out[\"v\"].sum()\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_llm": "import time\nimport random\nimport numpy as np\nimport pandas as pd\n\n# Récursion coûteuse (sans cache)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = ''.join(str(int((x * y) * 1000) % 7) for _ in range(50))\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = [i % 5 for i in range(200)]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame({\"v\": df[\"z\"]})\n\n    # Somme non vectorisée\n    total = out[\"v\"].sum()\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_selected": "import time\nimport random\nimport numpy as np\nimport pandas as pd\n\n# Récursion coûteuse (sans cache)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.iterrows():\n        tmp = pd.DataFrame({\"v\": [r[\"z\"]]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = 0\n    for v in out[\"v\"]:\n        total = total + v\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()"}
{"id": "c086f54c-19ba-402b-8113-12a4a7b0a77d", "ts": "2025-11-14T09:14:13Z", "page": "rag", "choice_label": "AST", "choice_key": "ast", "comment": "trés bonne optimisation", "code_before": "import time\r\nimport random\r\nimport numpy as np\r\nimport pandas as pd\r\n\r\n# Récursion coûteuse (sans cache)\r\ndef fib(n):\r\n    if n <= 1:\r\n        return n\r\n    return fib(n - 1) + fib(n - 2)\r\n\r\n# Fonction lente appelée par pandas.apply\r\ndef slow_row_apply(row):\r\n    x, y = row[\"a\"], row[\"b\"]\r\n\r\n    # Concaténation de chaînes dans une boucle (inefficace)\r\n    s = \"\"\r\n    for _ in range(50):\r\n        s += str(int((x * y) * 1000) % 7)\r\n\r\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\r\n    arr = []\r\n    for i in range(200):\r\n        arr = arr + [i % 5]\r\n\r\n    z = sum(arr)\r\n\r\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\r\n    if random.random() < 0.001:\r\n        time.sleep(0.01)\r\n\r\n    # Appel récursif coûteux par ligne\r\n    return fib(22) + z + len(s)\r\n\r\ndef main():\r\n    # Petit dataset pour rester raisonnable en temps d'exécution\r\n    df = pd.DataFrame({\r\n        \"a\": np.random.rand(50),\r\n        \"b\": np.random.rand(50),\r\n    })\r\n\r\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\r\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\r\n\r\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\r\n    out = pd.DataFrame()\r\n    for _, r in df.iterrows():\r\n        tmp = pd.DataFrame({\"v\": [r[\"z\"]]})\r\n        out = pd.concat([out, tmp])  # anti-pattern\r\n\r\n    # Somme non vectorisée\r\n    total = 0\r\n    for v in out[\"v\"]:\r\n        total = total + v\r\n\r\n    print(\"total:\", total)\r\n\r\nif __name__ == \"__main__\":\r\n    main()", "code_after_hetero": "", "code_after_simple": "", "code_after_ast": "import time\nimport random\nimport numpy as np\nimport pandas as pd\nfrom functools import lru_cache\n\n# Récursion coûteuse (avec cache)\n@lru_cache(None)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.iterrows():\n        tmp = pd.DataFrame({\"v\": [r[\"z\"]]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = out[\"v\"].sum()\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()", "code_after_llm": "", "code_after_selected": "import time\nimport random\nimport numpy as np\nimport pandas as pd\nfrom functools import lru_cache\n\n# Récursion coûteuse (avec cache)\n@lru_cache(None)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Fonction lente appelée par pandas.apply\ndef slow_row_apply(row):\n    x, y = row[\"a\"], row[\"b\"]\n\n    # Concaténation de chaînes dans une boucle (inefficace)\n    s = \"\"\n    for _ in range(50):\n        s += str(int((x * y) * 1000) % 7)\n\n    # Croissance de liste par ré-assemblage (arr = arr + [..]) au lieu d'append/extend\n    arr = []\n    for i in range(200):\n        arr = arr + [i % 5]\n\n    z = sum(arr)\n\n    # Micro-sommeil inutile (occasionnel) pour polluer la durée d’exécution\n    if random.random() < 0.001:\n        time.sleep(0.01)\n\n    # Appel récursif coûteux par ligne\n    return fib(22) + z + len(s)\n\ndef main():\n    # Petit dataset pour rester raisonnable en temps d'exécution\n    df = pd.DataFrame({\n        \"a\": np.random.rand(50),\n        \"b\": np.random.rand(50),\n    })\n\n    # apply ligne-à-ligne (CPU-bound) au lieu de vectoriser\n    df[\"z\"] = df.apply(slow_row_apply, axis=1)\n\n    # Concaténation incrémentale de DataFrame dans une boucle (O(n^2))\n    out = pd.DataFrame()\n    for _, r in df.iterrows():\n        tmp = pd.DataFrame({\"v\": [r[\"z\"]]})\n        out = pd.concat([out, tmp])  # anti-pattern\n\n    # Somme non vectorisée\n    total = out[\"v\"].sum()\n\n    print(\"total:\", total)\n\nif __name__ == \"__main__\":\n    main()"}
